// (연계형 문제 - 88번을 먼저 풀고 오셔야 합니다!)
// 제코베의 도움을 받아 성공적으로 지도를 만들어낸 지식이는 캐릭터의 움직임을 구현했습니다. 
// 하지만 지도 위의 캐릭터 위치를 나타내는데 문제가 발생했습니다.
// 지식이는 지도 위에서 캐릭터의 위치를 나타내기 위해 다시 한번 제코베에 도움을 요청합니다.

// 지도 위에서 캐릭터의 위치를 나타내주세요

// 1. 지도는 88번 문제의 해답을 사용해 주세요
// 2. 입력값은 지도, 캐릭터의 움직임입니다.
// 3. 캐릭터의 움직임은 { 상:1, 하:2, 좌:3, 우:4 }로 정수로 이루어진 배열이 들어갑니다.
// 4. 벽과 장애물은 통과할 수 없습니다. 
// 5. 마지막 캐릭터의 위치를 반영한 지도를 보여주고 위치를 반환하는 함수를 작성해 주세요.

// ```jsx
// **데이터**
// 가로 = 4
// 세로 = 5
// 캐릭터위치 = [0, 0]
// 장애물 = [[0,1],[1,1],[2,3],[1,3]]
// console.log('캐릭터 이동 전 지도')
// 지도 = make_map(가로, 세로, 캐릭터위치, 장애물)

// 움직임 = [2,2,2,4,4,4]
// console.log('캐릭터 이동 후 지도')
// 캐릭터 위치 = move(지도, 움직임)

// **출력**
// 캐릭터 이동 전 지도
// [2, 2, 2, 2, 2, 2]
// [2, 1, 2, 0, 0, 2]
// [2, 0, 2, 0, 2, 2]
// [2, 0, 0, 0, 2, 2]
// [2, 0, 0, 0, 0, 2]
// [2, 0, 0, 0, 0, 2]
// [2, 2, 2, 2, 2, 2]

// 캐릭터 이동 후 지도
// [2, 2, 2, 2, 2, 2]
// [2, 0, 2, 0, 0, 2]
// [2, 0, 2, 0, 2, 2]
// [2, 0, 0, 0, 2, 2]
// [2, 0, 0, 0, 1, 2]
// [2, 0, 0, 0, 0, 2]
// [2, 2, 2, 2, 2, 2]
// 캐릭터위치 : [4, 4]
// ```

const 가로 = 4;
const 세로 = 5;
const 캐릭터위치 = [0,0];
const 장애물 = [[0,1],[1,1],[2,3],[1,3]];

function make_map(가로, 세로, 캐릭터위치, 장애물){
    // 지도 그리기
    let map = []
    let line = [];
    for (let i=0; i < 세로 + 2; i++){
        for (let j=0; j < 가로 + 2; j++){
            if (j === 0 || j === 가로 + 1 || i === 0 || i === 세로 + 1){
                line.push(2);
            }
            else {
                line.push(0);
            }
        }
        map.push(line);
        line = [];
    }
    // 캐릭터 세우기
    map[캐릭터위치[0] + 1][캐릭터위치[1] + 1] = 1;

    // 장애물 그리기
    장애물.forEach(item => {
        if (map[item[0] + 1][item[1] + 1] !== 1){
            map[item[0] + 1][item[1] + 1] = 2;
        }
    })
    return map;
}

const map = make_map(가로, 세로, 캐릭터위치, 장애물);
const 움직임 = [2,2,2,4,4,4];

console.log(move(map, 움직임, 캐릭터위치))
function move(map, 움직임, 캐릭터위치){
    let x = 캐릭터위치[1] + 1;
    let y = 캐릭터위치[0] + 1;
    
    map[y][x] = 0;
    for (let i of 움직임){
        if (i === 1 && map[y-1][x] !==2){
            // 상
            y--;
        }
        else if (i === 2 && map[y+1][x] !==2){
            // 하
            y++;
        }
        else if (i === 3 && map[y][x-1] !==2){
            // 좌
            x--;
        }
        else if (i === 4 && map[y][x+1] !==2){
            // 우
            x++;
        }
        
        
        
    }
    map[y][x] = 1;
    console.log(map);
    return [x,y];
}